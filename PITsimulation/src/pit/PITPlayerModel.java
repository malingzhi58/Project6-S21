package pit;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import javax.jms.*;
import javax.naming.*;

/*
 * This is the ONLY file that you are to edit.  It is the model of play for
 * every PITplayer.  Each PITplayer instantiates this model and uses it to
 * process the messages it receives.
 */
public class PITPlayerModel {

    // Each PITplayer has a unique myPlayerNumber.  It is set in the PITPlayer constructor.
    private final int myPlayerNumber;
    // Cards is this player's set of cards.
    private final ArrayList <String> cards = new ArrayList<>();
    // numTrades counts trades.
    private int numTrades = 0;
    // maxTrades is the maximum number of trades, after which trading is stopped.
    private final int maxTrades = 20000;
    // numPlayers are the number of Players trading.  This comes with a NewHand from the PITsnapshot servlet
    private int numPlayers = 0;
    // halting indicates that the system is being reset, so ignore trades until a new had received
    private boolean halting = false;

    /* The snapshot servlet (PITsnapshot) is expecting to be passed an ObjectMessage
     * where the  object is a HashMap. Therefore this definition of HashMap is
     * provided although it  is not currently used (it is for you to use).
     * PITsnapshot is expecting a  set of attibute/value pairs. These include the player
     * number, as in state.put("Player",myPlayerNumber),  and each commodity string
     * and the number of that commodity  in the snapshot.
     * Also included below is a utility method  that will convert a HashMap into a string
     * which is useful for printing diagnostic messages to  the console.
     */
    private HashMap<String, Integer> state;
    // PITPlayerModel constructor saves what number player this object represents.
    PITPlayerModel(int myNumber) {
        myPlayerNumber = myNumber;
    }

    public void onMessage(Message message) {
        try {
            if (message instanceof ObjectMessage) {
                Object o = ((ObjectMessage) message).getObject();

                /*
                 * There are 6 types of messages:  Reset, NewHand, TenderOffer,
                 * AcceptOffer, RejectOffer, and Marker
                 */

                String messageType = o.getClass().toString().replaceFirst("class pit.","");
                switch (messageType) {
                    // Reset the Player.  This message is generated by the PITsnapshot servlet
                    case "Reset":
                        resetGame((Reset) o);
                        break;
                    // NewHand received from PITsnapshot. Add the new hand into cards.
                    case "NewHand":
                        if (stopTrading()) break;  // This would be weird.
                        addNewHand((NewHand) o);
                        // Offer a card to another Player
                        tenderOffer();
                        break;
                    // Receive an offer from another Player
                    case "TenderOffer":
                        if (stopTrading()) break;
                        considerTender((TenderOffer) o);
                        break;
                    // Another Player accepted our offer
                    case "AcceptOffer":
                        if (stopTrading()) break;
                        processAcceptedOffer((AcceptOffer) o);
                        break;
                    // Another Player rejected our offer
                    case "RejectOffer":
                        if (stopTrading()) break;
                        processRejectedOffer((RejectOffer) o);
                        break;
                    default:
                        log(" received unknown Message type");
                        // just ignore it
                }
            }
        } catch (Exception e) {
            log("exception" + e);
        }
    }

    private void resetGame(Reset reset) throws Exception {
        // Resetting is done by two messages, first to halt, then to clear
        if (reset.action == Reset.HALT) {
            log (" received Reset HALT");
            halting = true;
        } else { // action == Reset.CLEAR
            log (" received Reset CLEAR");
            // Drop all cards in hand
            cards.clear();
            numTrades = 0;
            numPlayers = 0;
            halting = false;
        }
        // Reply acknowledgement to the PITsnapshot
        sendToQueue("PITmonitor", reset);
    }

    private void addNewHand(NewHand hand) {
        // Note the number of players
        numPlayers = (hand).numPlayers;
        // Add a new hand of cards.
        // It is actually possible that an offer from another Player has been
        // accepted already, beating the NewHand
        cards.addAll((hand).newHand);
        log (" new hand: " + toString(cards));
    }

    private void considerTender(TenderOffer trade) throws Exception {

        log (" received offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);

        // When receiving an offer, decide whether to Accept or Reject it
        if (Math.random() < 0.2) {                  // Reject the trade 20% of the time
            doReplyReject(trade);                   // And send it back
        } else {                                    // Otherwise accept the offer
            cards.add(trade.tradeCard);             // Add the Offer to my hand of cards
            doReplyAccept(trade.sourcePlayer);      // Pay with one of my cards
        }
    }

    // Handle receiving a message that a previous offer has been accepted.
    // They would have replied with another card as payment.
    private void processAcceptedOffer(AcceptOffer trade) throws Exception {
        // Having received a AcceptOffer from another Player, add it to my hand of cards
        cards.add(trade.tradeCard);

        log (" received: " + trade.tradeCard + " as payment from player: " + trade.sourcePlayer);
        log (" hand: " + toString(cards));
        // Make another offer to a random player
        tenderOffer();
    }

    // Handle receiving a reject message regarding a prior offer I made
    private void processRejectedOffer(RejectOffer trade) throws Exception {
        // Because the offer was rejected, and returned, add it back into my cards
        cards.add(trade.tradeCard);

        log (" received rejected offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);
        log (" hand: " + toString(cards));
        // Make another offer to a random player
        tenderOffer();
    }

    // Make an offer to a random player
    private void tenderOffer() throws Exception {
        /*
         * If numPlayers == 0, while we have received a TenderOffer, we have not
         * received our NewHand yet, so we don't know how many players there
         * are.  Therefore, don't send out a TenderOffer at this time.
         *
         */
        if (numPlayers == 0) {
            return;
        }

        // Create a new offer from my set of cards, and send to another player
        TenderOffer newTrade = new TenderOffer();
        newTrade.tradeCard = cards.remove(0);
        newTrade.sourcePlayer = myPlayerNumber;

        // Find a random player to trade to (not including myself)
        int sendTo = myPlayerNumber;
        while (sendTo == myPlayerNumber) {
            sendTo = Math.round((float) Math.random() * (numPlayers - 1));
        }

        //Send the card to the other player
        log (" offered: " + newTrade.tradeCard + " to player: " + sendTo);
        String sendToJNDI = "PITplayer" + sendTo;
        sendToQueue(sendToJNDI, newTrade);
    }

    private void doReplyAccept(int sendTo) throws Exception {
        // In payment for the card I just accepted, send back one of my cards.
        AcceptOffer newTrade = new AcceptOffer();
        newTrade.tradeCard = cards.remove(0);
        newTrade.sourcePlayer = myPlayerNumber;

        //Send the card to the other player
        log (" accepting offer and paying with: " + newTrade.tradeCard + " to player: " + sendTo);
        log (" hand: " + toString(cards));
        String sendToJNDI = "PITplayer" + sendTo;
        sendToQueue(sendToJNDI, newTrade);
    }

    // Reply rejecting an offer that was received.  Send back their card.
    private void doReplyReject(TenderOffer trade) throws Exception {
        log (" rejecting offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);
        log (" hand: " + toString(cards));

        // Send back their card that I am rejecting
        RejectOffer newTrade = new RejectOffer();
        newTrade.tradeCard = trade.tradeCard;
        newTrade.sourcePlayer = myPlayerNumber;

        //Send the card to the other player
        String sendToJNDI = "PITplayer" + trade.sourcePlayer;
        sendToQueue(sendToJNDI, newTrade);
    }

    // Create a string of hand size and all cards
    private String toString(ArrayList <String> hand) {
        String cardsString = "size: " + hand.size() + " ";
        for (String s : hand) {
            cardsString += s + " ";
        }
        return cardsString;
    }

    // Create a printable version of the state
    private String toString(HashMap<String, Integer> state) {
        String stateString = "";
        for (Iterator it = state.entrySet().iterator(); it.hasNext();) {
            Map.Entry entry = (Map.Entry) it.next();
            String commodity = (String) entry.getKey();
            int number = (Integer) entry.getValue();
            stateString += "{" + commodity + ":" + number + "} ";
        }
        return stateString;
    }

    // Send an object to a Queue, given its JNDI name
    private void sendToQueue(String queueJNDI, Serializable message) throws Exception {
        // Gather necessary JMS resources
        Context ctxt = new InitialContext();
        Connection con = ((ConnectionFactory) ctxt.lookup("openejb:Resource/myConnectionFactory")).createConnection();
        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Queue q = (Queue) ctxt.lookup("openejb:Resource/"+queueJNDI);
        MessageProducer writer = session.createProducer(q);
        ObjectMessage msg = session.createObjectMessage(message);
        // Send the object to the Queue
        writer.send(msg);
        session.close();
        con.close();
        ctxt.close();
    }

    // Stop trading when the max number of Trades is reached
    private boolean maxTrades(int max) {
        if ((numTrades % 100) == 0) {
            log (" numTrades: " + numTrades);
        }
        return numTrades++ >= max;
    }

    // Is it time to stop trading?
    private boolean stopTrading() {
        if (halting) {
            return true;
        } else if (maxTrades(maxTrades)) { // if hit maxTrades limit, then stop sending trades
            halting = true;
            return true;
        }
        return false;
    }

    private void log(String s) {
        System.out.println("PITplayer" + myPlayerNumber + ": " + s);
    }
}
